4月27日 22:32:33 开始翻译

4月27日 22:32:35 翻译注释:
// Seek 实现了 [io.Seeker] 接口。 // md5:407fc18ddaadacba

4月27日 22:32:36 翻译注释:
// WriteTo 实现了 [io.WriterTo] 接口。 // md5:93bec25fa975a33f

4月27日 22:32:37 翻译注释:
// Reset 将 [Reader] 重置为从 s 读取。 // md5:c28a6e41efb01d72

4月27日 22:32:38 翻译注释:
// NewReader 返回一个新的[Reader]，从s中读取。
// 它类似于[bytes.NewBufferString]，但更高效且不可写。
// md5:59cc3f598d36d163

4月27日 22:32:38 命中翻译缓存:
// NewReader 返回一个新的[Reader]，从s中读取。
// 它类似于[bytes.NewBufferString]，但更高效且不可写。
// md5:59cc3f598d36d163

4月27日 22:32:38 翻译注释:
// 版权归2012年的Go作者所有。保留所有权利。
// 使用此源代码受BSD风格的
// 许可证管理，可在LICENSE文件中找到。
// md5:a2b8441cca608eb8

4月27日 22:32:40 翻译注释:
// 为竞态条件检测器进行的测试，以验证 ReadAt 方法不改变任何状态。
// md5:9cd790971d166721

4月27日 22:32:42 翻译注释:
// 此测试用于检测竞态条件检测器，以确认多个goroutine使用一个没有读取到任何字节的Read操作是安全的。
// 这是我们历史上的行为。
// 参见golang.org/issue/7856
// md5:ec9e90217f9da7a3

4月27日 22:32:43 翻译注释:
// 测试Len是否受读取影响，但Size不受影响。 // md5:1c7a92525f02f091

4月27日 22:32:43 命中翻译缓存:
// 测试Len是否受读取影响，但Size不受影响。 // md5:1c7a92525f02f091

4月27日 22:32:43 翻译注释:
// 版权所有 2011 Go 语言作者。保留所有权利。
// 使用此源代码须遵循 BSD 风格的许可协议，
// 许可协议具体内容可在 LICENSE 文件中找到。
// md5:b5bcbe8a534f6077

4月27日 22:32:44 翻译注释:
// Replacer 将一个字符串列表替换为替换项。它被设计为多个goroutine并发使用是安全的。
// md5:9f92262c73bf0188

4月27日 22:32:45 翻译注释:
// 保护 buildOnce 方法 // md5:d8adecf11217de44

4月27日 22:32:46 翻译注释:
// replacer 是一个替换算法需要实现的接口。 // md5:55767533de787b2c

4月27日 22:32:48 翻译注释:
// NewReplacer 从一组旧的、新的字符串对中返回一个新的[Replacer]。替换操作按照它们在目标字符串中出现的顺序进行，不会重叠匹配。旧字符串的比较是按参数顺序进行的。
// 
// 如果给定的参数数量为奇数，NewReplacer 会引发 panic。
// md5:717e3888dde3a5a1

4月27日 22:32:50 翻译注释:
// 第一个与旧字符串匹配的old->new映射会优先于其他具有相同旧字符串的映射。
// md5:c04c6c8da80ad26b

4月27日 22:32:52 翻译注释:
// 为了避免重复计数多次。 // md5:c7f363185266d4b3

4月27日 22:32:54 翻译注释:
// 我们需要使用 string([]byte{o}) 而不是 string(o)，
// 以避免对 o 进行 utf8 编码。
// 例如，byte(150) 会产生长度为 2 的字符串。
// md5:f1a8c16e52cec431

4月27日 22:32:54 翻译注释:
// Replace 返回一个对所有替换操作后的s的副本。 // md5:6bb464346ccde2d8

4月27日 22:32:55 翻译注释:
// WriteString 将所有替换操作后的 s 写入到 w。 // md5:fbeb91d7113bdc7f

4月27日 22:33:12 翻译注释:
// trieNode 是优先级键值对查找 Trie 中的一个节点。键和值都可以为空。例如，包含键 "ax"、"ay"、"bcbc"、"x" 和 "xy" 的 Trie 可能有八个节点：
//
//	n0  -
//	n1  a-
//	n2  .x+
//	n3  .y+
//	n4  b-
//	n5  .cbc+
//	n6  x+
//	n7  .y+
//
// n0 是根节点，其子节点为 n1、n4 和 n6；n1 的子节点是 n2 和 n3；n4 的子节点是 n5；n6 的子节点是 n7。带有尾部 "-" 标记的节点 n0、n1 和 n4 是部分键，而带有尾部 "+" 标记的节点 n2、n3、n5、n6 和 n7 是完整键。
// md5:7c3fccc16018bdb4

4月27日 22:33:13 翻译注释:
// value 是字典树节点的键值对中的值。如果该节点不是一个完整的键，则为空。
// md5:3b140f9c90cd6ce1

4月27日 22:33:16 翻译注释:
// priority 是字典树节点的键/值对的优先级（数值越大表示越重要）；键不一定按照最短或最长匹配。如果这个节点是一个完整的键，则优先级为正，否则为零。在上面的例子中，正/零优先级用"+"或"-"标记。
// md5:b3181a6a4aceff2b

4月27日 22:33:19 翻译注释:
// Trie节点可能有零个、一个或多个子节点：
//  * 如果剩余字段为零，没有子节点。
//  * 如果prefix和next非零，有一个子节点在next中。
//  * 如果table非零，它定义了所有子节点。
// 
// 当只有一个子节点时，优先使用前缀，但根节点始终为了查找效率使用table。
// md5:dc0b9f748792008b

4月27日 22:33:25 翻译注释:
// prefix 表示当前 Trie 节点与下一个 Trie 节点在键值上的差异。
// 在上面的例子中，节点 n4 的前缀是 "cbc"，而 n4 的下一个节点是 n5。
// 节点 n5 没有子节点，因此它的前缀、下一个节点和表字段都为零。
// md5:f12200afb771a4c0

4月27日 22:33:30 翻译注释:
// table 是一个查找表，索引由密钥的下一个字节（经过genericReplacer.mapping的映射转换以创建稠密索引）组成。在上面的例子中，键只使用了 'a', 'b', 'c', 'x' 和 'y'，它们映射为 0, 1, 2, 3 和 4。所有其他字节映射为 5，而 genericReplacer.tableSize 将为 5。节点 n0 的表将为 []*trieNode{ 0:n1, 1:n4, 3:n6 }，其中的 0, 1 和 3 分别是映射后的 'a', 'b' 和 'x'。
// md5:008e9b6267f0b796

4月27日 22:33:31 翻译注释:
// 需要将前缀分配给多个节点。 // md5:1db7b555fee65929

4月27日 22:33:32 翻译注释:
// 最长公共前缀的长度 // md5:41adf1facc8167cd

