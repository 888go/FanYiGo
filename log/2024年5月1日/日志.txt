5ÔÂ1ÈÕ 23:58:59 ¿ªÊ¼ÌáÈ¡×¢ÊÍ

5ÔÂ1ÈÕ 23:58:59 ĞÂÔö×¢ÊÍ:
// String returns the time formatted using the format string
//
//	"2006-01-02 15:04:05.999999999 -0700 MST"
//
// If the time has a monotonic clock reading, the returned string
// includes a final field "m=¡À<value>", where value is the monotonic
// clock reading formatted as a decimal number of seconds.
//
// The returned string is meant for debugging; for a stable serialized
// representation, use t.MarshalText, t.MarshalBinary, or t.Format
// with an explicit format string.

5ÔÂ1ÈÕ 23:58:59 ĞÂÔö×¢ÊÍ:
// A Ticker holds a channel that delivers ¡°ticks¡± of a clock
// at intervals.

5ÔÂ1ÈÕ 23:58:59 ĞÂÔö×¢ÊÍ:
// A Time represents an instant in time with nanosecond precision.
//
// Programs using times should typically store and pass them as values,
// not pointers. That is, time variables and struct fields should be of
// type time.Time, not *time.Time.
//
// A Time value can be used by multiple goroutines simultaneously except
// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and
// UnmarshalText are not concurrency-safe.
//
// Time instants can be compared using the Before, After, and Equal methods.
// The Sub method subtracts two instants, producing a Duration.
// The Add method adds a Time and a Duration, producing a Time.
//
// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
// As this time is unlikely to come up in practice, the IsZero method gives
// a simple way of detecting a time that has not been initialized explicitly.
//
// Each time has an associated Location. The methods Local, UTC, and In return a
// Time with a specific Location. Changing the Location of a Time value with
// these methods does not change the actual instant it represents, only the time
// zone in which to interpret it.
//
// Representations of a Time value saved by the GobEncode, MarshalBinary,
// MarshalJSON, and MarshalText methods store the Time.Location's offset, but not
// the location name. They therefore lose information about Daylight Saving Time.
//
// In addition to the required ¡°wall clock¡± reading, a Time may contain an optional
// reading of the current process's monotonic clock, to provide additional precision
// for comparison or subtraction.
// See the ¡°Monotonic Clocks¡± section in the package documentation for details.
//
// Note that the Go == operator compares not just the time instant but also the
// Location and the monotonic clock reading. Therefore, Time values should not
// be used as map or database keys without first guaranteeing that the
// identical Location has been set for all values, which can be achieved
// through use of the UTC or Local method, and that the monotonic clock reading
// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
// to t == u, since t.Equal uses the most accurate comparison available and
// correctly handles the case when only one of its arguments has a monotonic
// clock reading.

5ÔÂ1ÈÕ 23:58:59 ÌáÈ¡×¢ÊÍÍê±Ï

5ÔÂ1ÈÕ 23:59:0 ¿ªÊ¼·­Òë

5ÔÂ1ÈÕ 23:59:10 ·­Òë×¢ÊÍ:
// String ·½·¨·µ»ØÊ¹ÓÃ¸ñÊ½×Ö·û´®¸ñÊ½»¯µÄÊ±¼ä¡£
//
//	¸ñÊ½×Ö·û´®Îª£º"2006-01-02 15:04:05.999999999 -0700 MST"
//
// Èç¹ûÊ±¼ä°üº¬µ¥µ÷Ê±ÖÓ¶ÁÊı£¬·µ»ØµÄ×Ö·û´®»á¸½¼ÓÒ»¸ö×îºóµÄ×Ö¶Î "m=¡À<Öµ>"£¬ÆäÖĞ <Öµ> ÊÇµ¥µ÷Ê±ÖÓ¶ÁÊıÒÔÃëÎªµ¥Î»µÄÊ®½øÖÆÊı±íÊ¾¡£
//
// ·µ»ØµÄ×Ö·û´®Ö÷ÒªÓÃÓÚµ÷ÊÔ£»ÈôĞèÒªÎÈ¶¨µÄĞòÁĞ»¯±íÊ¾£¬ÇëÊ¹ÓÃ t.MarshalText¡¢t.MarshalBinary »òÕß t.Format ²¢Ìá¹©Ã÷È·µÄ¸ñÊ½×Ö·û´®¡£
// md5:534437fd6587d3d7

5ÔÂ1ÈÕ 23:59:12 ·­Òë×¢ÊÍ:
// Ticker ÓÃÓÚ³ÖÓĞÔÚ¹Ì¶¨¼ä¸ô·¢ËÍÊ±ÖÓ¡°µÎ´ğ¡±ĞÅºÅµÄÍ¨µÀ¡£
// md5:b1cdec933a8caca4

5ÔÂ1ÈÕ 23:59:28 ·­Òë×¢ÊÍ:
// Time ±íÊ¾Ê±¼ä£¬¾ßÓĞÄÉÃë¾«¶È¡£
// 
// Ê¹ÓÃÊ±¼äµÄ³ÌĞòÍ¨³£»á½«ËüÃÇ×÷ÎªÖµ´æ´¢ºÍ´«µİ£¬¶ø²»ÊÇÖ¸Õë¡£Ò²¾ÍÊÇËµ£¬Ê±¼ä±äÁ¿ºÍ½á¹¹Ìå×Ö¶ÎÓ¦Îª time.Time ÀàĞÍ£¬¶ø²»ÊÇ *time.Time ÀàĞÍ¡£
// 
// Ê±¼äÖµ¿ÉÒÔÔÚ¶à¸ögoroutineÖĞÍ¬Ê±Ê¹ÓÃ£¬³ıÁË GobDecode¡¢UnmarshalBinary¡¢UnmarshalJSON ºÍ UnmarshalText ·½·¨²»ÊÇ²¢·¢°²È«µÄ¡£
// 
// ¿ÉÒÔÊ¹ÓÃ Before¡¢After ºÍ Equal ·½·¨±È½ÏÊ±¼äµã¡£Sub ·½·¨¿ÉÒÔ¼õÈ¥Á½¸öÊ±¼äµã£¬µÃµ½Ò»¸ö Duration¡£Add ·½·¨¿ÉÒÔÌí¼ÓÒ»¸ö Time ºÍÒ»¸ö Duration£¬µÃµ½Ò»¸öĞÂµÄ Time¡£
// 
// Ê±¼äÀàĞÍµÄÁãÖµ±íÊ¾ UTC µÄ¹«Ôª 1 Äê 1 ÔÂ 1 ÈÕ 00:00:00.000000000¡£ÓÉÓÚÕâ¸öÊ±¼äÔÚÊµ¼ÊÓ¦ÓÃÖĞºÜÉÙ³öÏÖ£¬IsZero ·½·¨Ìá¹©ÁËÒ»ÖÖ¼òµ¥µÄ·½·¨À´¼ì²âÎ´Ã÷È·³õÊ¼»¯µÄÊ±¼ä¡£
// 
// Ã¿¸öÊ±¼ä¶¼ÓĞÒ»¸ö¹ØÁªµÄ Location£¨Ê±Çø£©¡£Local¡¢UTC ºÍ In ·½·¨·µ»Ø¾ßÓĞÌØ¶¨ Location µÄ Time¡£Í¨¹ıÕâĞ©·½·¨¸ü¸Ä Time ÖµµÄ Location ²»»á¸Ä±äËüËù´ú±íµÄÊµ¼ÊÊ±¿Ì£¬Ö»»á¸Ä±äÆä½âÎöÊ±µÄÊ±Çø¡£
// 
// GobEncode¡¢MarshalBinary¡¢MarshalJSON ºÍ MarshalText ·½·¨±£´æµÄÊ±¼äÖµ±íÊ¾ĞÎÊ½´æ´¢ÁË Time.Location µÄÆ«ÒÆÁ¿£¬µ«²»°üº¬Ê±ÇøÃû³Æ£¬Òò´Ë¶ªÊ§ÁËÏÄÁîÊ±µÄĞÅÏ¢¡£
// 
// ³ıÁË»ù±¾µÄ¡°Ç½ÖÓ¡±¶ÁÈ¡Íâ£¬Time »¹¿ÉÄÜ°üº¬µ±Ç°½ø³ÌµÄµ¥µ÷¼ÆÊ±Æ÷¶ÁÈ¡£¬ÒÔÌá¹©±È½Ï»ò¼õ·¨²Ù×÷µÄ¶îÍâ¾«¶È¡£ÓĞ¹ØÏêÏ¸ĞÅÏ¢£¬Çë²ÎÔÄ°üÎÄµµÖĞµÄ¡°µ¥µ÷¼ÆÊ±Æ÷¡±²¿·Ö¡£
// 
// ×¢Òâ Go ÖĞµÄ == ÔËËã·û²»½ö±È½ÏÊ±¼äµã£¬»¹±È½Ï Location ºÍµ¥µ÷¼ÆÊ±Æ÷¶ÁÈ¡¡£Òò´Ë£¬ÔÚ½« Time ÖµÓÃ×÷ map »òÊı¾İ¿â¼üÖ®Ç°£¬ĞèÒªÈ·±£ËùÓĞÖµ¶¼ÉèÖÃÁËÏàÍ¬µÄ Location£¨Í¨¹ıÊ¹ÓÃ UTC »ò Local ·½·¨£©£¬²¢ÒÆ³ıµ¥µ÷¼ÆÊ±Æ÷¶ÁÈ¡£¬Õâ¿ÉÒÔÍ¨¹ıÉèÖÃ t = t.Round(0) À´ÊµÏÖ¡£Ò»°ãÀ´Ëµ£¬ÍÆ¼öÊ¹ÓÃ t.Equal(u) ¶ø²»ÊÇ t == u£¬ÒòÎª t.Equal Ê¹ÓÃ×î×¼È·µÄ±È½Ï·½·¨£¬²¢ÕıÈ·´¦ÀíÖ»ÓĞÒ»¸ö²ÎÊı¾ßÓĞµ¥µ÷¼ÆÊ±Æ÷¶ÁÈ¡µÄÇé¿ö¡£
// md5:98b88205e2fd3c1e

5ÔÂ1ÈÕ 23:59:28 Í¨ÒåÇ§ÎÊ·­ÒëÍê±Ï

5ÔÂ1ÈÕ 23:59:32 ¿ªÊ¼Ìæ»»×¢ÊÍ

5ÔÂ1ÈÕ 23:59:32 ¿ªÊ¼Ìæ»»×¢ÊÍ

5ÔÂ1ÈÕ 23:59:50 Ìæ»»×¢ÊÍ:
// String returns the time formatted using the format string
//
//	"2006-01-02 15:04:05.999999999 -0700 MST"
//
// If the time has a monotonic clock reading, the returned string
// includes a final field "m=Â±<value>", where value is the monotonic
// clock reading formatted as a decimal number of seconds.
//
// The returned string is meant for debugging; for a stable serialized
// representation, use t.MarshalText, t.MarshalBinary, or t.Format
// with an explicit format string.

5ÔÂ1ÈÕ 23:59:51 Ìæ»»×¢ÊÍ:
// A Ticker holds a channel that delivers â€œticksâ€ of a clock
// at intervals.

5ÔÂ1ÈÕ 23:59:51 Ìæ»»×¢ÊÍ:
// A Time represents an instant in time with nanosecond precision.
//
// Programs using times should typically store and pass them as values,
// not pointers. That is, time variables and struct fields should be of
// type time.Time, not *time.Time.
//
// A Time value can be used by multiple goroutines simultaneously except
// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and
// UnmarshalText are not concurrency-safe.
//
// Time instants can be compared using the Before, After, and Equal methods.
// The Sub method subtracts two instants, producing a Duration.
// The Add method adds a Time and a Duration, producing a Time.
//
// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
// As this time is unlikely to come up in practice, the IsZero method gives
// a simple way of detecting a time that has not been initialized explicitly.
//
// Each time has an associated Location. The methods Local, UTC, and In return a
// Time with a specific Location. Changing the Location of a Time value with
// these methods does not change the actual instant it represents, only the time
// zone in which to interpret it.
//
// Representations of a Time value saved by the GobEncode, MarshalBinary,
// MarshalJSON, and MarshalText methods store the Time.Location's offset, but not
// the location name. They therefore lose information about Daylight Saving Time.
//
// In addition to the required â€œwall clockâ€ reading, a Time may contain an optional
// reading of the current process's monotonic clock, to provide additional precision
// for comparison or subtraction.
// See the â€œMonotonic Clocksâ€ section in the package documentation for details.
//
// Note that the Go == operator compares not just the time instant but also the
// Location and the monotonic clock reading. Therefore, Time values should not
// be used as map or database keys without first guaranteeing that the
// identical Location has been set for all values, which can be achieved
// through use of the UTC or Local method, and that the monotonic clock reading
// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
// to t == u, since t.Equal uses the most accurate comparison available and
// correctly handles the case when only one of its arguments has a monotonic
// clock reading.

5ÔÂ2ÈÕ 0:0:3 Ìæ»»×¢ÊÍÍê±Ï

5ÔÂ2ÈÕ 0:25:18 ¿ªÊ¼ÌáÈ¡×¢ÊÍ

5ÔÂ2ÈÕ 0:25:18 ĞÂÔö×¢ÊÍ:
// A Duration represents the elapsed time between two instants
// as an int64 nanosecond count. The representation limits the
// largest representable duration to approximately 290 years.

5ÔÂ2ÈÕ 0:25:18 ÌáÈ¡×¢ÊÍÍê±Ï

5ÔÂ2ÈÕ 0:25:19 ¿ªÊ¼·­Òë

5ÔÂ2ÈÕ 0:25:21 ·­Òë×¢ÊÍ:
// Duration ±íÊ¾Á½¸öË²¼äÖ®¼äµÄÊ±¼ä²î£¬ÓÃÒ»¸ö int64 Ãë¼¶±ğµÄÄÉÃë¼ÆÊı±íÊ¾¡£Õâ¸ö±íÊ¾·½Ê½ÏŞÖÆÁË¿É±íÊ¾µÄ×î³¤³ÖĞøÊ±¼ä´óÔ¼Îª 290 Äê¡£
// md5:4c8441d90787436e

5ÔÂ2ÈÕ 0:25:21 Í¨ÒåÇ§ÎÊ·­ÒëÍê±Ï

5ÔÂ2ÈÕ 0:25:24 ¿ªÊ¼Ìæ»»×¢ÊÍ

5ÔÂ2ÈÕ 0:25:24 ¿ªÊ¼Ìæ»»×¢ÊÍ

5ÔÂ2ÈÕ 0:25:44 Ìæ»»×¢ÊÍ:
// A Duration represents the elapsed time between two instants
// as an int64 nanosecond count. The representation limits the
// largest representable duration to approximately 290 years.

5ÔÂ2ÈÕ 0:25:55 Ìæ»»×¢ÊÍÍê±Ï

5ÔÂ2ÈÕ 0:26:2 ¿ªÊ¼ÌáÈ¡×¢ÊÍ

5ÔÂ2ÈÕ 0:26:2 ÌáÈ¡×¢ÊÍÍê±Ï

5ÔÂ2ÈÕ 0:26:8 ¿ªÊ¼·­Òë

5ÔÂ2ÈÕ 0:26:8 Í¨ÒåÇ§ÎÊ·­ÒëÍê±Ï

5ÔÂ2ÈÕ 0:26:9 ¿ªÊ¼Ìæ»»×¢ÊÍ

5ÔÂ2ÈÕ 0:26:9 ¿ªÊ¼Ìæ»»×¢ÊÍ

5ÔÂ2ÈÕ 0:26:41 Ìæ»»×¢ÊÍÍê±Ï

